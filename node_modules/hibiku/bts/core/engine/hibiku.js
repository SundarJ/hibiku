const fs = require('fs');
const utils = require('../utils');
const config = require('../config');
const path = require('path');

const parse = require('pegjs').buildParser(
    fs.readFileSync(path.join(config.root, "bts/core/engine/hibiku-parse.pegjs"), 'utf-8')
).parse;

var files = [];
const extRegex = new RegExp("\\" + config.engine.extension + "$");
utils.walk(config.engine.views, function(f, s) {
    f.match(extRegex) && files.push(f.replace(extRegex, ''));
});

var template = {
    files: (function(files) {
        var ret = {};
        files.forEach(function(file) {
            var lastFolder = file.split(path.sep);
            lastFolder = lastFolder[lastFolder.length - 2];
            var hook = config.engine.views.indexOf(lastFolder) === -1 ? lastFolder + '/' + path.basename(file) : path.basename(file);
            ret[hook] = fs.readFileSync(file + config.engine.extension, 'utf-8');
        });
        return ret;
    })(files)
}

var helpers = [':each'];

function render(data, options) {
    
    var context, replace;
    
    data = data.split("\n").map(function(line) {
        var tags = line.match(/\(\([^]+?\)\)/g);
        if (tags) {
            var parsed = parse(tags.join(''));
            parsed.forEach(function(tag) {
                tag = tag.filter(utils.filter.truthy);
                var s = '';
                var token;
                tag.forEach(function(part) {
                    if (part.token) {
                        s += token = part.token;
                        if (part.context) {
                            context = part.context;
                        } else {
                            if (context) {
                                if (typeof replace === 'undefined') // this is a line following a helper
                                    replace = true;
                            }
                        }
                    } else {
                        s+=part;   
                    }
                });
                if (replace) {
                    line = options[context].map(function(item) {
                        return line.replace(utils.regex.create(s, "g"), item)
                    }).join("\n");
                    replace = context = false;
                } else if ((token[0] === ':') || token === 'skip') {
                    // these will get filtered out by utils.filter.truthy
                    line = false;
                } else if (token[0] === '>') { // include
                    var view = options['_view'].replace(path.basename(options['_view']), '');
                    line = fs.readFileSync(view + token.slice(1) + config.engine.extension);
                } else {
                    line = line.replace(s, options[token]);   
                }
            });
        }
        return line;
    }).filter(utils.filter.truthy).join('\n');
    
    return data;
    
}

module.exports = {
    render: render
}