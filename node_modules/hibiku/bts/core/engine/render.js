const fs = require('fs');
const utils = require('../utils');
const path = require('path');

const parse = require('pegjs').buildParser(
    fs.readFileSync(path.join(settings.root, "bts/core/engine/hibiku-parse.pegjs"), 'utf-8')
).parse;

const helpers = {
    ':each': function(line, details) {
        return details.global.map(function(item) {
            return line.replace(utils.regex.create("(("+details.local+"))", "g"), item);
        }).join('\n');
    }
};

function render(data, options) {
    
    var insideHelper;
    
    function act(line, parsed) {
        var ret, helper = false, context;
        parsed.forEach(function(tag) {
            if (tag.token === 'include') {
                const view = options['_view'];
                ret = render(fs.readFileSync(view + path.sep + tag.context + settings.engine.extension, 'utf-8'), {lang: settings.user.options.locale});
            } else if (tag.token === 'anchor') {
                if (insideHelper) {
                    return ret = helpers[insideHelper.helper](line, {
                       local: tag.context,
                       global: options[insideHelper.context]
                    });
                }
                ret = line.replace('(('+tag.context+'))', options[tag.context]);
            } else if (!!tag.helper) {
                helper = true;
                insideHelper = tag;
            } else {
                throw new Error('render error: invalid token');
            }
        });
        
        if (!helper)
            insideHelper = false;
        return ret;
    };
    
    data = data.split("\n").map(function(line) {
        var tags = line.match(/\(\([^]+?\)\)/g);
        if (tags) {
            var parsed = parse(tags.join(''));
            if (parsed[0]) {
                line = act(line, parsed);
            } else {
                line = false;
            }
        }
        return line;
    }).filter(utils.filter.truthy).join("\n");
    
    //console.log(data);
    return data;
    
};

module.exports = render;
